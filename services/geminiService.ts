
import { GoogleGenAI, Type } from "@google/genai";

// Assume process.env.API_KEY is configured in the environment
const API_KEY = process.env.API_KEY;

if (!API_KEY) {
    console.warn("API_KEY is not set. AI features will be disabled.");
}

const ai = new GoogleGenAI({ apiKey: API_KEY! });
const model = "gemini-2.5-flash";

export interface GeneratedCardData {
    cardType: 'QA' | 'Cloze' | 'MCQ';
    front: string;
    back: string;
    explanation?: string;
}

const flashcardSchema = {
    type: Type.ARRAY,
    items: {
      type: Type.OBJECT,
      properties: {
        cardType: {
          type: Type.STRING,
          enum: ['QA', 'Cloze', 'MCQ'],
          description: 'The type of the flashcard.'
        },
        front: {
          type: Type.STRING,
          description: 'The front side of the flashcard (question, statement with a blank, etc.). For Cloze, use {{c1::word}} syntax.',
        },
        back: {
          type: Type.STRING,
          description: 'The back side of the flashcard (answer).',
        },
        explanation: {
            type: Type.STRING,
            description: 'A brief explanation of the answer.'
        }
      },
      required: ['cardType', 'front', 'back'],
    },
};

export const generateFlashcardsFromText = async (text: string): Promise<GeneratedCardData[]> => {
    if (!API_KEY) {
        // Mock response for development if API key is not available
        console.log("Using mock data because API_KEY is not available.");
        await new Promise(res => setTimeout(res, 1000));
        return [
            { cardType: 'QA', front: 'What is photosynthesis?', back: 'A process used by plants to convert light energy into chemical energy.', explanation: 'It converts carbon dioxide and water into glucose and oxygen.' },
            { cardType: 'Cloze', front: 'The green pigment responsible for absorbing light is called {{c1::chlorophyll}}.', back: 'chlorophyll', explanation: 'This pigment is located in the chloroplasts.' },
        ];
    }
    try {
        const prompt = `Based on the following text, generate a diverse set of flashcards in JSON format. The flashcards should be a mix of Question/Answer (QA), Cloze deletions (using {{c1::word}} syntax), and multiple choice questions (MCQ). For each card, provide a front, a back, an explanation, and the card type. Avoid creating duplicate concepts. One key concept per card.

Text:
---
${text}
---
`;

        const response = await ai.models.generateContent({
            model,
            contents: prompt,
            config: {
                responseMimeType: "application/json",
                responseSchema: flashcardSchema,
            },
        });

        const jsonStr = response.text.trim();
        const generatedCards = JSON.parse(jsonStr) as GeneratedCardData[];
        return generatedCards;

    } catch (error) {
        console.error("Error generating flashcards:", error);
        throw new Error("Failed to generate flashcards from AI.");
    }
};

export type ExplainStyle = 'simple' | 'detailed' | 'academic';

export const explainText = async (text: string, style: ExplainStyle): Promise<string> => {
    if (!API_KEY) {
        await new Promise(res => setTimeout(res, 1000));
        return `This is a mock explanation in a **${style}** style for the provided text. In a real scenario, this would be a detailed breakdown generated by the Gemini API. The explanation would be tailored to the selected style, providing either a simple overview, a detailed analysis, or an academic perspective.`;
    }
    try {
        const prompt = `Explain the following text in a ${style} manner.
- For "simple", use easy-to-understand language and analogies.
- For "detailed", break down key components and provide examples.
- For "academic", use formal language, technical terms, and cite theoretical concepts.
Format the response using Markdown.

Text:
---
${text}
---
`;
        const response = await ai.models.generateContent({ model, contents: prompt });
        return response.text;
    } catch (error) {
        console.error("Error generating explanation:", error);
        throw new Error("Failed to generate explanation from AI.");
    }
};

export const queryWithContext = async (query: string, context: string): Promise<string> => {
    if (!API_KEY) {
        await new Promise(res => setTimeout(res, 1000));
        return `This is a mock answer for your query: "${query}". Based on the context provided, the AI would synthesize an answer here. It would reference the specific information found in your notes to provide a relevant and accurate response.`;
    }
    try {
        const prompt = `Based ONLY on the following context from a user's notes, answer the user's question.
If the context doesn't contain the answer, state that you couldn't find an answer in their notes.
Cite the source notes by title when possible. Format the response using Markdown.

Context:
---
${context}
---

Question: ${query}
`;
        const response = await ai.models.generateContent({ model, contents: prompt });
        return response.text;
    } catch (error) {
        console.error("Error generating RAG response:", error);
        throw new Error("Failed to generate answer from AI.");
    }
};
